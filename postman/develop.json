{
  "info": {
    "_postman_id": "2e23e399-5485-4bab-b029-539f093fdaaa",
    "name": "Test Explore With Me - Main service",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "_exporter_id": "22464779"
  },
  "item": [
    {
      "name": "Validation",
      "item": [
        {
          "name": "Required query params",
          "item": [
            {
              "name": "Добавление запроса от текущего пользователя на участие в событии без обязательного query params",
              "event": [
                {
                  "listen": "prerequest",
                  "script": {
                    "exec": [
                      "const main = async () => {\r",
                      "    const api = new API(pm);\r",
                      "    const rnd = new RandomUtils();\r",
                      "\r",
                      "    try {\r",
                      "        const submittedUser = await api.addUser(rnd.getUser());\r",
                      "        pm.request.removeQueryParams(['eventId']);\r",
                      "        pm.collectionVariables.set('uid', submittedUser.id);\r",
                      "    } catch(err) {\r",
                      "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                      "    }\r",
                      "};\r",
                      "\r",
                      "const interval = setInterval(() => {}, 1000);\r",
                      "\r",
                      "setTimeout(async () => \r",
                      "    {\r",
                      "        try {\r",
                      "            // выполняем наш скрипт\r",
                      "            await main();\r",
                      "        } catch (e) {\r",
                      "            console.error(e);\r",
                      "        } finally {\r",
                      "            clearInterval(interval);\r",
                      "        }\r",
                      "    },  \r",
                      "    100 \r",
                      ");"
                    ],
                    "type": "text/javascript"
                  }
                },
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Ответ должен содержать код статуса 400 и данные в формате json\", function () {\r",
                      "    pm.response.to.be.badRequest;    \r",
                      "    pm.response.to.be.withBody;\r",
                      "    pm.response.to.be.json;\r",
                      "});\r",
                      "\r",
                      "const target = pm.response.json();\r",
                      "\r",
                      "pm.test(\"Ошибка должна содержать поля: status\", function () {\r",
                      "    pm.expect(target).to.have.property('status');\r",
                      "});\r",
                      ""
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/users/:userId/requests",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users",
                    ":userId",
                    "requests"
                  ],
                  "query": [
                    {
                      "key": "eventId",
                      "value": "0",
                      "description": "(Required) id события",
                      "disabled": true
                    }
                  ],
                  "variable": [
                    {
                      "key": "userId",
                      "value": "{{uid}}",
                      "description": "(Required) id текущего пользователя"
                    }
                  ]
                },
                "description": "Обратите внимание:\n- нельзя добавить повторный запрос\n- инициатор события не может добавить запрос на участие в своём событии\n- нельзя участвовать в неопубликованном событии\n- если у события достигнут лимит запросов на участие - необходимо вернуть ошибку\n- если для события отключена пре-модерация запросов на участие, то запрос должен автоматически перейти в состояние подтвержденного"
              },
              "response": []
            }
          ]
        },
        {
          "name": "Unrequired query params",
          "item": [
            {
              "name": "Поиск пользователей без нескольких Query params",
              "event": [
                {
                  "listen": "prerequest",
                  "script": {
                    "exec": [
                      "const main = async () => {\r",
                      "    const api = new API(pm);\r",
                      "    const rnd = new RandomUtils();\r",
                      "\r",
                      "    let compilation;\r",
                      "    try {\r",
                      "        const user = await api.addUser(rnd.getUser());\r",
                      "        pm.collectionVariables.set(\"uid\", user.id)\r",
                      "    } catch(err) {\r",
                      "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                      "    }\r",
                      "};\r",
                      "\r",
                      "const interval = setInterval(() => {}, 1000);\r",
                      "\r",
                      "setTimeout(async () => \r",
                      "    {\r",
                      "        try {\r",
                      "            await main();\r",
                      "        } catch (e) {\r",
                      "            console.error(e);\r",
                      "        } finally {\r",
                      "            clearInterval(interval);\r",
                      "        }\r",
                      "    },  \r",
                      "    100 \r",
                      ");"
                    ],
                    "type": "text/javascript"
                  }
                },
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                      "    pm.response.to.be.ok;    \r",
                      "    pm.response.to.be.withBody;\r",
                      "    pm.response.to.be.json;\r",
                      "});"
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/admin/users?ids={{uid}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "admin",
                    "users"
                  ],
                  "query": [
                    {
                      "key": "ids",
                      "value": "{{uid}}",
                      "description": "id пользователей"
                    },
                    {
                      "key": "from",
                      "value": "0",
                      "description": "количество элементов, которые нужно пропустить для формирования текущего набора",
                      "disabled": true
                    },
                    {
                      "key": "size",
                      "value": "10",
                      "description": "количество элементов в наборе",
                      "disabled": true
                    }
                  ]
                }
              },
              "response": []
            },
            {
              "name": "Поиск событий без нескольких Query params",
              "event": [
                {
                  "listen": "prerequest",
                  "script": {
                    "exec": [
                      "const main = async () => {\r",
                      "    const api = new API(pm);\r",
                      "    const rnd = new RandomUtils();\r",
                      "\r",
                      "    try {\r",
                      "        const user = await api.addUser(rnd.getUser());\r",
                      "        const category = await api.addCategory(rnd.getCategory());\r",
                      "        let event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                      "        event = await api.publishEvent(event.id);\r",
                      "        pm.request.removeQueryParams(['users', 'categories']);\r",
                      "        pm.request.addQueryParams([`users=` + user.id, 'categories=' + category.id]);\r",
                      "    } catch(err) {\r",
                      "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                      "    }\r",
                      "};\r",
                      "\r",
                      "const interval = setInterval(() => {}, 1000);\r",
                      "\r",
                      "setTimeout(async () => \r",
                      "    {\r",
                      "        try {\r",
                      "            // выполняем наш скрипт\r",
                      "            await main();\r",
                      "        } catch (e) {\r",
                      "            console.error(e);\r",
                      "        } finally {\r",
                      "            clearInterval(interval);\r",
                      "        }\r",
                      "    },  \r",
                      "    100 \r",
                      ");"
                    ],
                    "type": "text/javascript"
                  }
                },
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                      "    pm.response.to.be.ok;    \r",
                      "    pm.response.to.be.withBody;\r",
                      "    pm.response.to.be.json;\r",
                      "});"
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/admin/events",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "admin",
                    "events"
                  ],
                  "query": [
                    {
                      "key": "users",
                      "value": "0",
                      "description": "список id пользователей, чьи события нужно найти",
                      "disabled": true
                    },
                    {
                      "key": "states",
                      "value": "PUBLISHED",
                      "description": "список состояний в которых находятся искомые события",
                      "disabled": true
                    },
                    {
                      "key": "categories",
                      "value": "0",
                      "description": "список id категорий в которых будет вестись поиск",
                      "disabled": true
                    },
                    {
                      "key": "rangeStart",
                      "value": "2022-01-06%2013%3A30%3A38",
                      "description": "дата и время не раньше которых должно произойти событие",
                      "disabled": true
                    },
                    {
                      "key": "rangeEnd",
                      "value": "2097-09-06%2013%3A30%3A38",
                      "description": "дата и время не позже которых должно произойти событие",
                      "disabled": true
                    },
                    {
                      "key": "from",
                      "value": "0",
                      "description": "количество событий, которые нужно пропустить для формирования текущего набора",
                      "disabled": true
                    },
                    {
                      "key": "size",
                      "value": "1000",
                      "description": "количество событий в наборе",
                      "disabled": true
                    }
                  ]
                },
                "description": "Эндпоинт возвращает полную информацию обо всех событиях подходящих под переданные условия"
              },
              "response": []
            },
            {
              "name": "Получение событий, добавленных текущим пользователем без нескольких Query params",
              "event": [
                {
                  "listen": "prerequest",
                  "script": {
                    "exec": [
                      "const main = async () => {\r",
                      "    const api = new API(pm);\r",
                      "    const rnd = new RandomUtils();\r",
                      "\r",
                      "    try {\r",
                      "        const user = await api.addUser(rnd.getUser());\r",
                      "        pm.collectionVariables.set(\"uid\", user.id)\r",
                      "        const category = await api.addCategory(rnd.getCategory());\r",
                      "        const event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                      "    } catch(err) {\r",
                      "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                      "    }\r",
                      "};\r",
                      "\r",
                      "const interval = setInterval(() => {}, 1000);\r",
                      "\r",
                      "setTimeout(async () => \r",
                      "    {\r",
                      "        try {\r",
                      "            await main();\r",
                      "        } catch (e) {\r",
                      "            console.error(e);\r",
                      "        } finally {\r",
                      "            clearInterval(interval);\r",
                      "        }\r",
                      "    },  \r",
                      "    100 \r",
                      ");"
                    ],
                    "type": "text/javascript"
                  }
                },
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                      "    pm.response.to.be.ok;    \r",
                      "    pm.response.to.be.withBody;\r",
                      "    pm.response.to.be.json;\r",
                      "});"
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/users/:userId/events",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users",
                    ":userId",
                    "events"
                  ],
                  "query": [
                    {
                      "key": "from",
                      "value": "0",
                      "description": "количество элементов, которые нужно пропустить для формирования текущего набора",
                      "disabled": true
                    },
                    {
                      "key": "size",
                      "value": "1000",
                      "description": "количество элементов в наборе",
                      "disabled": true
                    }
                  ],
                  "variable": [
                    {
                      "key": "userId",
                      "value": "{{uid}}",
                      "description": "(Required) id текущего пользователя"
                    }
                  ]
                }
              },
              "response": []
            },
            {
              "name": "Получение категорий без нескольких Query params",
              "event": [
                {
                  "listen": "prerequest",
                  "script": {
                    "exec": [
                      ""
                    ],
                    "type": "text/javascript"
                  }
                },
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                      "    pm.response.to.be.ok;    \r",
                      "    pm.response.to.be.withBody;\r",
                      "    pm.response.to.be.json;\r",
                      "});"
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/categories",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "categories"
                  ],
                  "query": [
                    {
                      "key": "from",
                      "value": "0",
                      "description": "количество категорий, которые нужно пропустить для формирования текущего набора",
                      "disabled": true
                    },
                    {
                      "key": "size",
                      "value": "10000",
                      "description": "количество категорий в наборе",
                      "disabled": true
                    }
                  ]
                }
              },
              "response": []
            },
            {
              "name": "Получение подборок событий без нескольких Query params",
              "event": [
                {
                  "listen": "prerequest",
                  "script": {
                    "exec": [
                      "const main = async () => {\r",
                      "    const api = new API(pm);\r",
                      "    const rnd = new RandomUtils();\r",
                      "\r",
                      "    try {\r",
                      "        const user = await api.addUser(rnd.getUser());\r",
                      "        const category = await api.addCategory(rnd.getCategory());\r",
                      "        const compilation = await api.addCompilation(rnd.getCompilation());\r",
                      "    } catch(err) {\r",
                      "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                      "    }\r",
                      "};\r",
                      "\r",
                      "const interval = setInterval(() => {}, 1000);\r",
                      "\r",
                      "setTimeout(async () => \r",
                      "    {\r",
                      "        try {\r",
                      "            // выполняем наш скрипт\r",
                      "            await main();\r",
                      "        } catch (e) {\r",
                      "            console.error(e);\r",
                      "        } finally {\r",
                      "            clearInterval(interval);\r",
                      "        }\r",
                      "    },  \r",
                      "    100 \r",
                      ");"
                    ],
                    "type": "text/javascript"
                  }
                },
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                      "    pm.response.to.be.ok;    \r",
                      "    pm.response.to.be.withBody;\r",
                      "    pm.response.to.be.json;\r",
                      "});"
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/compilations",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "compilations"
                  ],
                  "query": [
                    {
                      "key": "pinned",
                      "value": "true",
                      "description": "искать только закрепленные/не закрепленные подборки",
                      "disabled": true
                    },
                    {
                      "key": "from",
                      "value": "0",
                      "description": "количество элементов, которые нужно пропустить для формирования текущего набора",
                      "disabled": true
                    },
                    {
                      "key": "size",
                      "value": "1000",
                      "description": "количество элементов в наборе",
                      "disabled": true
                    }
                  ]
                }
              },
              "response": []
            },
            {
              "name": "Получение событий с возможностью фильтрации без нескольких Query params",
              "event": [
                {
                  "listen": "prerequest",
                  "script": {
                    "exec": [
                      "const main = async () => {\r",
                      "    const api = new API(pm);\r",
                      "    const rnd = new RandomUtils();\r",
                      "\r",
                      "    try {\r",
                      "        const user = await api.addUser(rnd.getUser());\r",
                      "        const category = await api.addCategory(rnd.getCategory());\r",
                      "        let event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                      "        event = await api.publishEvent(event.id);\r",
                      "        pm.request.removeQueryParams(['text', 'categories', 'paid']);\r",
                      "        pm.request.addQueryParams([`text=` + event.annotation, 'categories=' + category.id, 'paid=' + event.paid]);\r",
                      "    } catch(err) {\r",
                      "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                      "    }\r",
                      "};\r",
                      "\r",
                      "const interval = setInterval(() => {}, 1000);\r",
                      "\r",
                      "setTimeout(async () => \r",
                      "    {\r",
                      "        try {\r",
                      "            // выполняем наш скрипт\r",
                      "            await main();\r",
                      "        } catch (e) {\r",
                      "            console.error(e);\r",
                      "        } finally {\r",
                      "            clearInterval(interval);\r",
                      "        }\r",
                      "    },  \r",
                      "    100 \r",
                      ");"
                    ],
                    "type": "text/javascript"
                  }
                },
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                      "    pm.response.to.be.ok;    \r",
                      "    pm.response.to.be.withBody;\r",
                      "    pm.response.to.be.json;\r",
                      "});"
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/events",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "events"
                  ],
                  "query": [
                    {
                      "key": "text",
                      "value": "0",
                      "description": "текст для поиска в содержимом аннотации и подробном описании события",
                      "disabled": true
                    },
                    {
                      "key": "categories",
                      "value": "0",
                      "description": "список идентификаторов категорий в которых будет вестись поиск",
                      "disabled": true
                    },
                    {
                      "key": "paid",
                      "value": "true",
                      "description": "поиск только платных/бесплатных событий",
                      "disabled": true
                    },
                    {
                      "key": "rangeStart",
                      "value": "2022-01-06%2013%3A30%3A38",
                      "description": "дата и время не раньше которых должно произойти событие",
                      "disabled": true
                    },
                    {
                      "key": "rangeEnd",
                      "value": "2097-09-06%2013%3A30%3A38",
                      "description": "дата и время не позже которых должно произойти событие",
                      "disabled": true
                    },
                    {
                      "key": "onlyAvailable",
                      "value": "false",
                      "description": "только события у которых не исчерпан лимит запросов на участие",
                      "disabled": true
                    },
                    {
                      "key": "sort",
                      "value": "EVENT_DATE",
                      "description": "Вариант сортировки: по дате события или по количеству просмотров",
                      "disabled": true
                    },
                    {
                      "key": "from",
                      "value": "0",
                      "description": "количество событий, которые нужно пропустить для формирования текущего набора",
                      "disabled": true
                    },
                    {
                      "key": "size",
                      "value": "1000",
                      "description": "количество событий в наборе",
                      "disabled": true
                    }
                  ]
                },
                "description": "Обратите внимание: \n- это публичный эндпоинт, соответственно в выдаче должны быть только опубликованные события\n- текстовый поиск (по аннотации и подробному описанию) должен быть без учета регистра букв\n- если в запросе не указан диапазон дат [rangeStart-rangeEnd], то нужно выгружать события, которые произойдут позже текущей даты и времени\n- информация о каждом событии должна включать в себя количество просмотров и количество уже одобренных заявок на участие\n- информацию о том, что по этому эндпоинту был осуществлен и обработан запрос, нужно сохранить в сервисе статистики"
              },
              "response": []
            }
          ]
        },
        {
          "name": "Required params in body",
          "item": [
            {
              "name": "Изменение категории с некорректным body",
              "event": [
                {
                  "listen": "prerequest",
                  "script": {
                    "exec": [
                      "const main = async () => {\r",
                      "    const api = new API(pm);\r",
                      "    const rnd = new RandomUtils();\r",
                      "    let category\r",
                      "    try {\r",
                      "        category = await api.addCategory(rnd.getCategory());\r",
                      "        pm.collectionVariables.set(\"catid\", category.id)\r",
                      "    } catch(err) {\r",
                      "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                      "    }\r",
                      "    pm.request.body.update({\r",
                      "        mode: 'raw',\r",
                      "        raw: JSON.stringify({}),\r",
                      "        options: { raw: { language: 'json' } }\r",
                      "    });\r",
                      "};\r",
                      "\r",
                      "const interval = setInterval(() => {}, 1000);\r",
                      "\r",
                      "setTimeout(async () => \r",
                      "    {\r",
                      "        try {\r",
                      "            await main();\r",
                      "        } catch (e) {\r",
                      "            console.error(e);\r",
                      "        } finally {\r",
                      "            clearInterval(interval);\r",
                      "        }\r",
                      "    },  \r",
                      "    100 \r",
                      ");"
                    ],
                    "type": "text/javascript"
                  }
                },
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Ответ должен содержать код статуса 400 и данные в формате json\", function () {\r",
                      "    pm.response.to.be.badRequest;    \r",
                      "    pm.response.to.be.withBody;\r",
                      "    pm.response.to.be.json;\r",
                      "});\r",
                      "\r",
                      "const target = pm.response.json();\r",
                      "\r",
                      "pm.test(\"Ошибка должна содержать поле: status\", function () {\r",
                      "pm.expect(target).to.have.property('status');\r",
                      "});\r",
                      ""
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "PATCH",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/admin/categories",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "admin",
                    "categories"
                  ]
                },
                "description": "Обратите внимание: имя категории должно быть уникальным"
              },
              "response": []
            },
            {
              "name": "Добавление пользователя с некорректным body",
              "event": [
                {
                  "listen": "prerequest",
                  "script": {
                    "exec": [
                      "const main = async () => {\r",
                      "    const api = new API(pm);\r",
                      "    const rnd = new RandomUtils();\r",
                      "\r",
                      "    let user;\r",
                      "    try {\r",
                      "        user = {\r",
                      "            email: pm.variables.replaceIn('{{$randomEmail}}')\r",
                      "        };\r",
                      "    } catch(err) {\r",
                      "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                      "    }\r",
                      "\r",
                      "    pm.request.body.update({\r",
                      "        mode: 'raw',\r",
                      "        raw: JSON.stringify(user),\r",
                      "        options: { raw: { language: 'json' } }\r",
                      "    });\r",
                      "};\r",
                      "\r",
                      "const interval = setInterval(() => {}, 1000);\r",
                      "\r",
                      "setTimeout(async () => \r",
                      "    {\r",
                      "        try {\r",
                      "            await main();\r",
                      "        } catch (e) {\r",
                      "            console.error(e);\r",
                      "        } finally {\r",
                      "            clearInterval(interval);\r",
                      "        }\r",
                      "    },  \r",
                      "    100 \r",
                      ");"
                    ],
                    "type": "text/javascript"
                  }
                },
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Ответ должен содержать код статуса 400 и данные в формате json\", function () {\r",
                      "    pm.response.to.be.badRequest;    \r",
                      "    pm.response.to.be.withBody;\r",
                      "    pm.response.to.be.json;\r",
                      "});\r",
                      "\r",
                      "const target = pm.response.json();\r",
                      "\r",
                      "pm.test(\"Ошибка должна содержать поле: status\", function () {\r",
                      "pm.expect(target).to.have.property('status');\r",
                      "});\r",
                      ""
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "POST",
                "header": [],
                "body": {
                  "mode": "raw",
                  "raw": ""
                },
                "url": {
                  "raw": "{{baseUrl}}/admin/users",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "admin",
                    "users"
                  ]
                }
              },
              "response": []
            },
            {
              "name": "Добавление подборки с некорректным body",
              "event": [
                {
                  "listen": "prerequest",
                  "script": {
                    "exec": [
                      "const main = async () => {\r",
                      "    const api = new API(pm);\r",
                      "    const rnd = new RandomUtils();\r",
                      "\r",
                      "    let compilation;\r",
                      "    try {\r",
                      "        const user = await api.addUser(rnd.getUser());\r",
                      "        const category = await api.addCategory(rnd.getCategory());\r",
                      "        const event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                      "        compilation = {\r",
                      "            \"pinned\":\"true\",\r",
                      "            \"events\":[event.id]};\r",
                      "    } catch(err) {\r",
                      "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                      "    }\r",
                      "\r",
                      "    pm.request.body.update({\r",
                      "        mode: 'raw',\r",
                      "        raw: JSON.stringify(compilation),\r",
                      "        options: { raw: { language: 'json' } }\r",
                      "    });\r",
                      "};\r",
                      "\r",
                      "const interval = setInterval(() => {}, 1000);\r",
                      "\r",
                      "setTimeout(async () => \r",
                      "    {\r",
                      "        try {\r",
                      "            await main();\r",
                      "        } catch (e) {\r",
                      "            console.error(e);\r",
                      "        } finally {\r",
                      "            clearInterval(interval);\r",
                      "        }\r",
                      "    },  \r",
                      "    100 \r",
                      ");"
                    ],
                    "type": "text/javascript"
                  }
                },
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Ответ должен содержать код статуса 400 и данные в формате json\", function () {\r",
                      "    pm.response.to.be.badRequest;    \r",
                      "    pm.response.to.be.withBody;\r",
                      "    pm.response.to.be.json;\r",
                      "});\r",
                      "\r",
                      "const target = pm.response.json();\r",
                      "\r",
                      "pm.test(\"Ошибка должна содержать поле: status\", function () {\r",
                      "pm.expect(target).to.have.property('status');\r",
                      "});\r",
                      ""
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/admin/compilations",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "admin",
                    "compilations"
                  ]
                }
              },
              "response": []
            },
            {
              "name": "Добавление категории с некорректным body",
              "event": [
                {
                  "listen": "prerequest",
                  "script": {
                    "exec": [
                      "const main = async () => {\r",
                      "    const api = new API(pm);\r",
                      "    const rnd = new RandomUtils();\r",
                      "\r",
                      "    let category;\r",
                      "    try {\r",
                      "        category = {};\r",
                      "    } catch(err) {\r",
                      "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                      "    }\r",
                      "\r",
                      "    pm.request.body.update({\r",
                      "        mode: 'raw',\r",
                      "        raw: JSON.stringify(category),\r",
                      "        options: { raw: { language: 'json' } }\r",
                      "    });\r",
                      "};\r",
                      "\r",
                      "const interval = setInterval(() => {}, 1000);\r",
                      "\r",
                      "setTimeout(async () => \r",
                      "    {\r",
                      "        try {\r",
                      "            await main();\r",
                      "        } catch (e) {\r",
                      "            console.error(e);\r",
                      "        } finally {\r",
                      "            clearInterval(interval);\r",
                      "        }\r",
                      "    },  \r",
                      "    100 \r",
                      ");"
                    ],
                    "type": "text/javascript"
                  }
                },
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Ответ должен содержать код статуса 400 и данные в формате json\", function () {\r",
                      "    pm.response.to.be.badRequest;    \r",
                      "    pm.response.to.be.withBody;\r",
                      "    pm.response.to.be.json;\r",
                      "});\r",
                      "\r",
                      "const target = pm.response.json();\r",
                      "\r",
                      "pm.test(\"Ошибка должна содержать поле: status\", function () {\r",
                      "pm.expect(target).to.have.property('status');\r",
                      "});\r",
                      ""
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "POST",
                "header": [],
                "body": {
                  "mode": "raw",
                  "raw": ""
                },
                "url": {
                  "raw": "{{baseUrl}}/admin/categories",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "admin",
                    "categories"
                  ]
                }
              },
              "response": []
            },
            {
              "name": "Добавление нового события с некорректным body",
              "event": [
                {
                  "listen": "prerequest",
                  "script": {
                    "exec": [
                      "const main = async () => {\r",
                      "    const api = new API(pm);\r",
                      "    const rnd = new RandomUtils();\r",
                      "\r",
                      "    let event;\r",
                      "    try {\r",
                      "        const user = await api.addUser(rnd.getUser());\r",
                      "        pm.collectionVariables.set(\"uid\", user.id)\r",
                      "        const category = await api.addCategory(rnd.getCategory());\r",
                      "        event = rnd.getEvent(category.id);\r",
                      "        delete event[\"annotation\"];\r",
                      "        delete event[\"description\"];\r",
                      "    } catch(err) {\r",
                      "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                      "    }\r",
                      "    console.log(event);\r",
                      "    pm.request.body.update({\r",
                      "        mode: 'raw',\r",
                      "        raw: JSON.stringify(event),\r",
                      "        options: { raw: { language: 'json' } }\r",
                      "    });\r",
                      "};\r",
                      "\r",
                      "const interval = setInterval(() => {}, 1000);\r",
                      "\r",
                      "setTimeout(async () => \r",
                      "    {\r",
                      "        try {\r",
                      "            await main();\r",
                      "        } catch (e) {\r",
                      "            console.error(e);\r",
                      "        } finally {\r",
                      "            clearInterval(interval);\r",
                      "        }\r",
                      "    },  \r",
                      "    100 \r",
                      ");"
                    ],
                    "type": "text/javascript"
                  }
                },
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      "pm.test(\"Ответ должен содержать код статуса 400 и данные в формате json\", function () {\r",
                      "    pm.response.to.be.badRequest;    \r",
                      "    pm.response.to.be.withBody;\r",
                      "    pm.response.to.be.json;\r",
                      "});\r",
                      "\r",
                      "const target = pm.response.json();\r",
                      "\r",
                      "pm.test(\"Ошибка должна содержать поле: status\", function () {\r",
                      "pm.expect(target).to.have.property('status');\r",
                      "});\r",
                      ""
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{{request_body}}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/users/:userId/events",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users",
                    ":userId",
                    "events"
                  ],
                  "variable": [
                    {
                      "key": "userId",
                      "value": "{{uid}}",
                      "description": "(Required) id текущего пользователя"
                    }
                  ]
                },
                "description": "Обратите внимание: дата и время на которые намечено событие не может быть раньше, чем через два часа от текущего момента"
              },
              "response": []
            }
          ]
        }
      ]
    },
    {
      "name": "409 Conflict",
      "item": [
        {
          "name": "Попытка изменения имени категории на уже существующее",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "    let category1, category2\r",
                  "    try {\r",
                  "        category1 = await api.addCategory(rnd.getCategory());\r",
                  "        category2 = await api.addCategory(rnd.getCategory());\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "    pm.request.body.update({\r",
                  "        mode: 'raw',\r",
                  "        raw: JSON.stringify({\r",
                  "            id : category2.id,\r",
                  "            name : category1.name\r",
                  "        }),\r",
                  "        options: { raw: { language: 'json' } }\r",
                  "    });\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 409 и данные в формате json\", function () {\r",
                  "    pm.response.to.have.status(409);\r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{request_body}}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/admin/categories",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "categories"
              ]
            },
            "description": "Обратите внимание: имя категории должно быть уникальным"
          },
          "response": []
        },
        {
          "name": "Добавление новой категории с занятым именем",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    let category;\r",
                  "    try {\r",
                  "        category = rnd.getCategory();\r",
                  "        await api.addCategory(category);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "\r",
                  "    pm.request.body.update({\r",
                  "        mode: 'raw',\r",
                  "        raw: JSON.stringify(category),\r",
                  "        options: { raw: { language: 'json' } }\r",
                  "    });\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 409 и данные в формате json\", function () {\r",
                  "    pm.response.to.have.status(409);\r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{request_body}}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/admin/categories",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "categories"
              ]
            },
            "description": "Обратите внимание: имя категории должно быть уникальным"
          },
          "response": []
        },
        {
          "name": "Добавление пользователя с занятым именем",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    let user;\r",
                  "    try {\r",
                  "        user = rnd.getUser();\r",
                  "        await api.addUser(user);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "\r",
                  "    pm.request.body.update({\r",
                  "        mode: 'raw',\r",
                  "        raw: JSON.stringify(user),\r",
                  "        options: { raw: { language: 'json' } }\r",
                  "    });\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 409 и данные в формате json\", function () {\r",
                  "    pm.response.to.have.status(409);\r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{request_body}}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/admin/users",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "users"
              ]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "Category",
      "item": [
        {
          "name": "Добавление новой категории",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    let category;\r",
                  "    try {\r",
                  "        category = rnd.getCategory();\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "\r",
                  "    pm.request.body.update({\r",
                  "        mode: 'raw',\r",
                  "        raw: JSON.stringify(category),\r",
                  "        options: { raw: { language: 'json' } }\r",
                  "    });\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = JSON.parse(pm.request.body.raw);\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Категория должна содержать поля: id, name\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('name');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(target.id).to.not.be.null;\r",
                  "    pm.expect(source.name).equal(target.name, 'Название категории должно совпадать с отправленным');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{request_body}}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/admin/categories",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "categories"
              ]
            },
            "description": "Обратите внимание: имя категории должно быть уникальным"
          },
          "response": []
        },
        {
          "name": "Получение категорий",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        pm.collectionVariables.set(\"response\", category)\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const target = pm.response.json();\r",
                  "let founded;\r",
                  "target.forEach(function(element){if (element.id == source.id) founded = element});\r",
                  "\r",
                  "pm.test(\"Категория должна содержать поля: id, name\", function () {\r",
                  "pm.expect(target[0]).to.have.property('id');\r",
                  "pm.expect(target[0]).to.have.property('name');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.id).equal(founded.id, 'Идентификатор категории должен соответствовать идентификатору категории добавленной ранее');\r",
                  "    pm.expect(source.name).equal(founded.name, 'Название категории должно соответствовать названию категории добавленной ранее');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/categories?from=0&size=1000",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "categories"
              ],
              "query": [
                {
                  "key": "from",
                  "value": "0",
                  "description": "количество категорий, которые нужно пропустить для формирования текущего набора"
                },
                {
                  "key": "size",
                  "value": "1000",
                  "description": "количество категорий в наборе"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Получение информации о категории по её идентификатору",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        pm.collectionVariables.set(\"response\", category)\r",
                  "        pm.collectionVariables.set(\"catid\", category.id)\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Категория должна содержать поля: id, name\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('name');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.id).equal(target.id, 'Идентификатор категории должен соответствовать идентификатору в запросе');\r",
                  "    pm.expect(source.name).equal(target.name, 'Название категории должно соответствовать названию категории с указанным идентификатором');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/categories/:catId",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "categories",
                ":catId"
              ],
              "variable": [
                {
                  "key": "catId",
                  "value": "{{catid}}",
                  "description": "(Required) id категории"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Изменение категории",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "    let category\r",
                  "    try {\r",
                  "        category = await api.addCategory(rnd.getCategory());\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "    pm.request.body.update({\r",
                  "        mode: 'raw',\r",
                  "        raw: JSON.stringify({\r",
                  "            id : category.id,\r",
                  "            name : rnd.getCategory().name\r",
                  "        }),\r",
                  "        options: { raw: { language: 'json' } }\r",
                  "    });\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = JSON.parse(pm.request.body.raw);\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Категория должна содержать поля: id, name\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('name');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(target.id).to.not.be.null;\r",
                  "    pm.expect(source.name).equal(target.name, 'Название категории должно совпадать с отправленным');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{request_body}}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/admin/categories",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "categories"
              ]
            },
            "description": "Обратите внимание: имя категории должно быть уникальным"
          },
          "response": []
        },
        {
          "name": "Удаление категории",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        const findedCategory = await api.findCategory(category.id);\r",
                  "        pm.collectionVariables.set(\"catid\", category.id)\r",
                  "        pm.collectionVariables.set(\"response\", findedCategory)\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "});\r",
                  "\r",
                  "source = pm.collectionVariables.get('response');\r",
                  "catId = pm.collectionVariables.get('catid');\r",
                  "\r",
                  "pm.test(\"Категория должна быть найдена до удаления\", function () {\r",
                  "    pm.expect(source.id).equal(catId, 'Идентификтор категории должен совпадать с удаляемым');\r",
                  "});\r",
                  "\r",
                  "pm.sendRequest({\r",
                  "            url: pm.collectionVariables.get(\"baseUrl\") + \"/categories/\" + catId,\r",
                  "            method: 'GET',\r",
                  "        }, (error, response) => {\r",
                  "            pm.test(\"Категория не должна быть найдена после удаления\", function () {\r",
                  "                pm.expect(response.code).to.eql(404);\r",
                  "            });\r",
                  "        });"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/admin/categories/:catId",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "categories",
                ":catId"
              ],
              "variable": [
                {
                  "key": "catId",
                  "value": "{{catid}}"
                }
              ]
            },
            "description": "Обратите внимание: с категорий не должно быть связано ни одного события."
          },
          "response": []
        }
      ]
    },
    {
      "name": "Users",
      "item": [
        {
          "name": "Поиск пользователей",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    let compilation;\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        pm.collectionVariables.set(\"uid\", user.id)\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Пользователи должны содержать поля: id, name, email\", function () {\r",
                  "    pm.expect(target[0]).to.have.property('id');\r",
                  "    pm.expect(target[0]).to.have.property('name');\r",
                  "    pm.expect(target[0]).to.have.property('email');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Должен быть найден только один пользователь по заданному фильтру\", function () {\r",
                  "    pm.expect(target.length).to.eql(1);\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(target[0].id).equal(pm.collectionVariables.get(\"uid\"));\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/admin/users?ids={{uid}}",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "users"
              ],
              "query": [
                {
                  "key": "ids",
                  "value": "{{uid}}",
                  "description": "id пользователей"
                },
                {
                  "key": "ids",
                  "value": "-10833646",
                  "description": "id пользователей",
                  "disabled": true
                },
                {
                  "key": "from",
                  "value": "0",
                  "description": "количество элементов, которые нужно пропустить для формирования текущего набора",
                  "disabled": true
                },
                {
                  "key": "size",
                  "value": "10",
                  "description": "количество элементов в наборе",
                  "disabled": true
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Добавление нового пользователя",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    let user;\r",
                  "    try {\r",
                  "        user = rnd.getUser();\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "\r",
                  "    pm.request.body.update({\r",
                  "        mode: 'raw',\r",
                  "        raw: JSON.stringify(user),\r",
                  "        options: { raw: { language: 'json' } }\r",
                  "    });\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = JSON.parse(pm.request.body.raw);\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Пользователь должен содержать поля: id, name, email\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('name');\r",
                  "pm.expect(target).to.have.property('email');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(target.id).to.not.be.null;\r",
                  "    pm.expect(source.name).equal(target.name, 'Имя пользователя должно соответствовать отправленному в запросе');\r",
                  "    pm.expect(source.email).equal(target.email, 'Почта пользователя должна соответствовать отправленной в запросе');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{request_body}}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/admin/users",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "users"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Удаление пользователя",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "});\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const userId = pm.collectionVariables.get('uid');\r",
                  "\r",
                  "pm.test(\"Пользователь должен быть найден до выполнения запроса\", function(){\r",
                  "    pm.expect(source.length).to.eql(1);\r",
                  "    pm.expect(source[0].id).to.eql(userId);\r",
                  "});\r",
                  "let body\r",
                  "const req = {\r",
                  "                url: \"http://localhost:8080/admin/users?ids=\" + pm.collectionVariables.get(\"uid\"),\r",
                  "                method: \"GET\",\r",
                  "                body: body == null ? \"\" : JSON.stringify(body),\r",
                  "                header: { \"Content-Type\": \"application/json\" },\r",
                  "            };\r",
                  "pm.sendRequest(req, (error, response) => {\r",
                  "    pm.test(\"Пользователь должен быть удалён после выполнения запроса\", function(){\r",
                  "        pm.expect(response.json().length).to.eql(0);\r",
                  "    });\r",
                  "})"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    let compilation;\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const foundedUser = await api.findUser(user.id);\r",
                  "        pm.collectionVariables.set(\"uid\", user.id);\r",
                  "        pm.collectionVariables.set(\"response\", foundedUser)\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/admin/users/:userId",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "users",
                ":userId"
              ],
              "variable": [
                {
                  "key": "userId",
                  "value": "{{uid}}",
                  "description": "(Required) id пользователя"
                }
              ]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "Event",
      "item": [
        {
          "name": "Добавление нового события",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    let event;\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        pm.collectionVariables.set(\"uid\", user.id)\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        event = rnd.getEvent(category.id);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "\r",
                  "    pm.request.body.update({\r",
                  "        mode: 'raw',\r",
                  "        raw: JSON.stringify(event),\r",
                  "        options: { raw: { language: 'json' } }\r",
                  "    });\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = JSON.parse(pm.request.body.raw);\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, description, participantLimit, state, createdOn, location, requestModeration\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('title');\r",
                  "pm.expect(target).to.have.property('annotation');\r",
                  "pm.expect(target).to.have.property('category');\r",
                  "pm.expect(target).to.have.property('paid');\r",
                  "pm.expect(target).to.have.property('eventDate');\r",
                  "pm.expect(target).to.have.property('initiator');\r",
                  "pm.expect(target).to.have.property('description');\r",
                  "pm.expect(target).to.have.property('participantLimit');\r",
                  "pm.expect(target).to.have.property('state');\r",
                  "pm.expect(target).to.have.property('createdOn');\r",
                  "pm.expect(target).to.have.property('location');\r",
                  "pm.expect(target).to.have.property('requestModeration');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(target.id).to.not.be.null;\r",
                  "    pm.expect(target.title).equal(source.title, 'Название события должно соответствовать названию события в запросе');\r",
                  "    pm.expect(target.annotation).equal(source.annotation, 'Аннотация события должна соответствовать аннотации события в запросе');\r",
                  "    pm.expect(target.paid.toString()).equal(source.paid.toString(), 'Стоимость события должна соответствовать стоимости события в запросе');\r",
                  "    pm.expect(target.eventDate).equal(source.eventDate, 'Дата проведения события должна соответствовать дате проведения события в запросе');\r",
                  "    pm.expect(target.description).equal(source.description, 'Описание события должно соответствовать описание события в запросе');\r",
                  "    pm.expect(target.participantLimit.toString()).equal(source.participantLimit.toString(), 'Лимит участников события должно соответствовать лимиту участников события в запросе');\r",
                  "    pm.expect(target.location.lat.toString()).equal(source.location.lat.toString(), 'Широта локации проведения события должна соответствовать широте локации проведения события в запросе');\r",
                  "    pm.expect(target.location.lon.toString()).equal(source.location.lon.toString(), 'Долгота локации проведения события должна соответствовать долготе локации проведения события в запросе');\r",
                  "    pm.expect(target.requestModeration.toString()).equal(source.requestModeration.toString(), 'Необходимость модерации события должна соответствовать необходимости модерации события в запросе');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{request_body}}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/users/:userId/events",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "users",
                ":userId",
                "events"
              ],
              "variable": [
                {
                  "key": "userId",
                  "value": "{{uid}}",
                  "description": "(Required) id текущего пользователя"
                }
              ]
            },
            "description": "Обратите внимание: дата и время на которые намечено событие не может быть раньше, чем через два часа от текущего момента"
          },
          "response": []
        },
        {
          "name": "Добавление запроса от текущего пользователя на участие в событии",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let eventBody = rnd.getEvent(category.id);\r",
                  "        eventBody['requestModeration'] = true\r",
                  "        let event = await api.addEvent(user.id, eventBody);\r",
                  "        event = await api.publishEvent(event.id);\r",
                  "        const submittedUser = await api.addUser(rnd.getUser());\r",
                  "        pm.request.removeQueryParams(['eventId']);\r",
                  "        pm.request.addQueryParams([`eventId=` + event.id]);\r",
                  "        pm.collectionVariables.set('uid', submittedUser.id);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const target = pm.response.json();\r",
                  "var query = {};\r",
                  "pm.request.url.query.all().forEach((param) => { query[param.key] = param.value});\r",
                  "\r",
                  "pm.test(\"Запрос на участие должен содержать поля: id, requester, event, status, created\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('requester');\r",
                  "pm.expect(target).to.have.property('event');\r",
                  "pm.expect(target).to.have.property('status');\r",
                  "pm.expect(target).to.have.property('created');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"При создании у запроса на участие должен быть статус PENDING\", function () {\r",
                  "    pm.expect(target.status).equal(\"PENDING\");\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Id ивента в запросе и в ответе должны совпадать\", function () {\r",
                  "    pm.expect(target.event.toString()).equal(query['eventId'].toString());\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/users/:userId/requests?eventId=0",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "users",
                ":userId",
                "requests"
              ],
              "query": [
                {
                  "key": "eventId",
                  "value": "0",
                  "description": "(Required) id события"
                }
              ],
              "variable": [
                {
                  "key": "userId",
                  "value": "{{uid}}",
                  "description": "(Required) id текущего пользователя"
                }
              ]
            },
            "description": "Обратите внимание:\n- нельзя добавить повторный запрос\n- инициатор события не может добавить запрос на участие в своём событии\n- нельзя участвовать в неопубликованном событии\n- если у события достигнут лимит запросов на участие - необходимо вернуть ошибку\n- если для события отключена пре-модерация запросов на участие, то запрос должен автоматически перейти в состояние подтвержденного"
          },
          "response": []
        },
        {
          "name": "Поиск событий",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                  "        event = await api.publishEvent(event.id);\r",
                  "        pm.request.removeQueryParams(['users', 'categories']);\r",
                  "        pm.request.addQueryParams([`users=` + user.id, 'categories=' + category.id]);\r",
                  "        pm.collectionVariables.set('response', event);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const target = pm.response.json()[0];\r",
                  "\r",
                  "pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, views, confirmedRequests, description, participantLimit, state, createdOn, publishedOn, location, requestModeration\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('title');\r",
                  "pm.expect(target).to.have.property('annotation');\r",
                  "pm.expect(target).to.have.property('category');\r",
                  "pm.expect(target).to.have.property('paid');\r",
                  "pm.expect(target).to.have.property('eventDate');\r",
                  "pm.expect(target).to.have.property('initiator');\r",
                  "pm.expect(target).to.have.property('views');\r",
                  "pm.expect(target).to.have.property('confirmedRequests');\r",
                  "pm.expect(target).to.have.property('description');\r",
                  "pm.expect(target).to.have.property('participantLimit');\r",
                  "pm.expect(target).to.have.property('state');\r",
                  "pm.expect(target).to.have.property('createdOn');\r",
                  "pm.expect(target).to.have.property('publishedOn');\r",
                  "pm.expect(target).to.have.property('location');\r",
                  "pm.expect(target).to.have.property('requestModeration');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.annotation).equal(target.annotation, 'Аннотация события должна соответствовать искомому событию');\r",
                  "    pm.expect(source.category.id).equal(target.category.id, 'Идентификатор категории должен соответствовать искомой категории');\r",
                  "    pm.expect(source.paid.toString()).equal(target.paid.toString(), 'Стоимость посещения события должна соответствовать искомому событию');\r",
                  "    pm.expect(source.eventDate).equal(target.eventDate, 'Дата проведения события должна соответствовать дате искомого события');\r",
                  "    pm.expect(source.description).equal(target.description, 'Описание события должно соответствовать искомому событию');\r",
                  "    pm.expect(source.title).equal(target.title, 'Название события должно соответствовать искомому событию');\r",
                  "    pm.expect(source.participantLimit.toString()).equal(target.participantLimit.toString(), 'Число участников события должно соответствовать искомому событию');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/admin/events?users=0&states=PUBLISHED&categories=0&rangeStart=2022-01-06%2013%3A30%3A38&rangeEnd=2097-09-06%2013%3A30%3A38&from=0&size=1000",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "events"
              ],
              "query": [
                {
                  "key": "users",
                  "value": "0",
                  "description": "список id пользователей, чьи события нужно найти"
                },
                {
                  "key": "states",
                  "value": "PUBLISHED",
                  "description": "список состояний в которых находятся искомые события"
                },
                {
                  "key": "categories",
                  "value": "0",
                  "description": "список id категорий в которых будет вестись поиск"
                },
                {
                  "key": "rangeStart",
                  "value": "2022-01-06%2013%3A30%3A38",
                  "description": "дата и время не раньше которых должно произойти событие"
                },
                {
                  "key": "rangeEnd",
                  "value": "2097-09-06%2013%3A30%3A38",
                  "description": "дата и время не позже которых должно произойти событие"
                },
                {
                  "key": "from",
                  "value": "0",
                  "description": "количество событий, которые нужно пропустить для формирования текущего набора"
                },
                {
                  "key": "size",
                  "value": "1000",
                  "description": "количество событий в наборе"
                }
              ]
            },
            "description": "Эндпоинт возвращает полную информацию обо всех событиях подходящих под переданные условия"
          },
          "response": []
        },
        {
          "name": "Получение событий, добавленных текущим пользователем",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        pm.collectionVariables.set(\"uid\", user.id)\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        const event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const target = pm.response.json()[0];\r",
                  "\r",
                  "pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate\", function () {\r",
                  "    pm.expect(target).to.contain.keys('id', 'title', 'annotation', 'category', 'paid', 'eventDate');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(target.id).to.not.be.null;\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/users/:userId/events?from=0&size=1000",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "users",
                ":userId",
                "events"
              ],
              "query": [
                {
                  "key": "from",
                  "value": "0",
                  "description": "количество элементов, которые нужно пропустить для формирования текущего набора"
                },
                {
                  "key": "size",
                  "value": "1000",
                  "description": "количество элементов в наборе"
                }
              ],
              "variable": [
                {
                  "key": "userId",
                  "value": "{{uid}}",
                  "description": "(Required) id текущего пользователя"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Получение событий с возможностью фильтрации",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                  "        event = await api.publishEvent(event.id);\r",
                  "        pm.request.removeQueryParams(['text', 'categories', 'paid']);\r",
                  "        pm.request.addQueryParams([`text=` + event.annotation, 'categories=' + category.id, 'paid=' + event.paid]);\r",
                  "        pm.collectionVariables.set('response', event);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const target = pm.response.json()[0];\r",
                  "\r",
                  "pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, views, confirmedRequests\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('title');\r",
                  "pm.expect(target).to.have.property('annotation');\r",
                  "pm.expect(target).to.have.property('category');\r",
                  "pm.expect(target).to.have.property('paid');\r",
                  "pm.expect(target).to.have.property('eventDate');\r",
                  "pm.expect(target).to.have.property('initiator');\r",
                  "pm.expect(target).to.have.property('views');\r",
                  "pm.expect(target).to.have.property('confirmedRequests');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.annotation).equal(target.annotation, 'Аннотация события должна соответствовать аннотации события с указанным идентификатором');\r",
                  "    pm.expect(source.category.id).equal(target.category.id, 'Категория события должна соответствовать категории события с указанным идентификатором');\r",
                  "    pm.expect(source.paid.toString()).equal(target.paid.toString(), 'Стоимость события должна соответствовать стоимости события с указанным идентификатором');\r",
                  "    pm.expect(source.eventDate).equal(target.eventDate, 'Дата проведения события должна соответствовать дате проведения события с указанным идентификатором');\r",
                  "    pm.expect(source.title).equal(target.title, 'Название события должно соответствовать названию события с указанным идентификатором');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/events?text=0&categories=0&paid=true&rangeStart=2022-01-06%2013%3A30%3A38&rangeEnd=2097-09-06%2013%3A30%3A38&onlyAvailable=false&sort=EVENT_DATE&from=0&size=1000",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "events"
              ],
              "query": [
                {
                  "key": "text",
                  "value": "0",
                  "description": "текст для поиска в содержимом аннотации и подробном описании события"
                },
                {
                  "key": "categories",
                  "value": "0",
                  "description": "список идентификаторов категорий в которых будет вестись поиск"
                },
                {
                  "key": "paid",
                  "value": "true",
                  "description": "поиск только платных/бесплатных событий"
                },
                {
                  "key": "rangeStart",
                  "value": "2022-01-06%2013%3A30%3A38",
                  "description": "дата и время не раньше которых должно произойти событие"
                },
                {
                  "key": "rangeEnd",
                  "value": "2097-09-06%2013%3A30%3A38",
                  "description": "дата и время не позже которых должно произойти событие"
                },
                {
                  "key": "onlyAvailable",
                  "value": "false",
                  "description": "только события у которых не исчерпан лимит запросов на участие"
                },
                {
                  "key": "sort",
                  "value": "EVENT_DATE",
                  "description": "Вариант сортировки: по дате события или по количеству просмотров"
                },
                {
                  "key": "from",
                  "value": "0",
                  "description": "количество событий, которые нужно пропустить для формирования текущего набора"
                },
                {
                  "key": "size",
                  "value": "1000",
                  "description": "количество событий в наборе"
                }
              ]
            },
            "description": "Обратите внимание: \n- это публичный эндпоинт, соответственно в выдаче должны быть только опубликованные события\n- текстовый поиск (по аннотации и подробному описанию) должен быть без учета регистра букв\n- если в запросе не указан диапазон дат [rangeStart-rangeEnd], то нужно выгружать события, которые произойдут позже текущей даты и времени\n- информация о каждом событии должна включать в себя количество просмотров и количество уже одобренных заявок на участие\n- информацию о том, что по этому эндпоинту был осуществлен и обработан запрос, нужно сохранить в сервисе статистики"
          },
          "response": []
        },
        {
          "name": "Получение подробной информации об опубликованном событии по его идентификатору",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                  "        event = await api.publishEvent(event.id);\r",
                  "        pm.collectionVariables.set(\"eid\", event.id)\r",
                  "        pm.collectionVariables.set('response', event);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, views, confirmedRequests, description, participantLimit, state, createdOn, publishedOn, location, requestModeration\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('title');\r",
                  "pm.expect(target).to.have.property('annotation');\r",
                  "pm.expect(target).to.have.property('category');\r",
                  "pm.expect(target).to.have.property('paid');\r",
                  "pm.expect(target).to.have.property('eventDate');\r",
                  "pm.expect(target).to.have.property('initiator');\r",
                  "pm.expect(target).to.have.property('views');\r",
                  "pm.expect(target).to.have.property('confirmedRequests');\r",
                  "pm.expect(target).to.have.property('description');\r",
                  "pm.expect(target).to.have.property('participantLimit');\r",
                  "pm.expect(target).to.have.property('state');\r",
                  "pm.expect(target).to.have.property('createdOn');\r",
                  "pm.expect(target).to.have.property('publishedOn');\r",
                  "pm.expect(target).to.have.property('location');\r",
                  "pm.expect(target).to.have.property('requestModeration');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.annotation).equal(target.annotation, 'Аннотация события должна соответствовать аннотации события с указанным идентификатором');\r",
                  "    pm.expect(source.category.id).equal(target.category.id, 'Категория события должна соответствовать категории события с указанным идентификатором');\r",
                  "    pm.expect(source.paid.toString()).equal(target.paid.toString(), 'Стоимость события должна соответствовать стоимости события с указанным идентификатором');\r",
                  "    pm.expect(source.eventDate).equal(target.eventDate, 'Дата проведения события должна соответствовать дате проведения события с указанным идентификатором');\r",
                  "    pm.expect(source.description).equal(target.description, 'Описание события должно соответствовать описанию события с указанным идентификатором');\r",
                  "    pm.expect(source.title).equal(target.title, 'Название события должно соответствовать названию события с указанным идентификатором');\r",
                  "    pm.expect(source.participantLimit.toString()).equal(target.participantLimit.toString(), 'Лимит участников события должен соответствовать лимиту участников события с указанным идентификатором');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/events/:id",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "events",
                ":id"
              ],
              "variable": [
                {
                  "key": "id",
                  "value": "{{eid}}",
                  "description": "(Required) id события"
                }
              ]
            },
            "description": "Обратите внимание:\n- событие должно быть опубликовано\n- информация о событии должна включать в себя количество просмотров и количество подтвержденных запросов\n- информацию о том, что по этому эндпоинту был осуществлен и обработан запрос, нужно сохранить в сервисе статистики"
          },
          "response": []
        },
        {
          "name": "Получение полной информации о событии добавленном текущим пользователем",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        pm.collectionVariables.set(\"uid\", user.id)\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        const event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                  "        pm.collectionVariables.set(\"eid\", event.id)\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, description, participantLimit, state, createdOn, location, requestModeration\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('title');\r",
                  "pm.expect(target).to.have.property('annotation');\r",
                  "pm.expect(target).to.have.property('category');\r",
                  "pm.expect(target).to.have.property('paid');\r",
                  "pm.expect(target).to.have.property('eventDate');\r",
                  "pm.expect(target).to.have.property('initiator');\r",
                  "pm.expect(target).to.have.property('description');\r",
                  "pm.expect(target).to.have.property('participantLimit');\r",
                  "pm.expect(target).to.have.property('state');\r",
                  "pm.expect(target).to.have.property('createdOn');\r",
                  "pm.expect(target).to.have.property('location');\r",
                  "pm.expect(target).to.have.property('requestModeration');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(target.id).to.not.be.null;\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/users/:userId/events/:eventId",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "users",
                ":userId",
                "events",
                ":eventId"
              ],
              "variable": [
                {
                  "key": "userId",
                  "value": "{{uid}}",
                  "description": "(Required) id текущего пользователя"
                },
                {
                  "key": "eventId",
                  "value": "{{eid}}",
                  "description": "(Required) id события"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Получение информации о заявках текущего пользователя на участие в чужих событиях",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let eventBody = rnd.getEvent(category.id);\r",
                  "        eventBody['requestModeration'] = true\r",
                  "        let event = await api.addEvent(user.id, eventBody);\r",
                  "        event = await api.publishEvent(event.id);\r",
                  "        const submittedUser = await api.addUser(rnd.getUser());\r",
                  "        const requestToJoin = await api.publishParticipationRequest(event.id, submittedUser.id);\r",
                  "        pm.collectionVariables.set('response', requestToJoin);\r",
                  "        pm.collectionVariables.set('uid', submittedUser.id);\r",
                  "\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const target = pm.response.json()[0];\r",
                  "\r",
                  "pm.test(\"Запрос на участие должен содержать поля: id, requester, event, status, created\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('requester');\r",
                  "pm.expect(target).to.have.property('event');\r",
                  "pm.expect(target).to.have.property('status');\r",
                  "pm.expect(target).to.have.property('created');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.id).equal(target.id, 'Идентификатор запроса на участие в событии должен соответствовать идентификатору запроса, созданного ранее');\r",
                  "    pm.expect(source.requester).equal(target.requester, 'Пользователя, запрашивающий доступ на участие в событии, должен соответствовать указанному пользователю');\r",
                  "    pm.expect(source.event).equal(target.event, 'Событие, доступ к которому запрашивает пользователь, должно соответствовать событию, доступ к которому пользователь запрашивал доступ ранее');\r",
                  "    pm.expect(source.created).equal(target.created, 'Время создания запроса на участие в событии должно соответствовать времени создания запроса, созданного ранее указанным пользователем');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/users/:userId/requests",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "users",
                ":userId",
                "requests"
              ],
              "variable": [
                {
                  "key": "userId",
                  "value": "{{uid}}",
                  "description": "(Required) id текущего пользователя"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Получение информации о запросах на участие в событии текущего пользователя",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let eventBody = rnd.getEvent(category.id);\r",
                  "        eventBody['requestModeration'] = true\r",
                  "        let event = await api.addEvent(user.id, eventBody);\r",
                  "        event = await api.publishEvent(event.id);\r",
                  "        const submittedUser = await api.addUser(rnd.getUser());\r",
                  "        const requestToJoin = await api.publishParticipationRequest(event.id, submittedUser.id);\r",
                  "        pm.collectionVariables.set('response', requestToJoin);\r",
                  "        pm.collectionVariables.set('uid', user.id);\r",
                  "        pm.collectionVariables.set('eid', event.id);\r",
                  "\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const target = pm.response.json()[0];\r",
                  "\r",
                  "pm.test(\"Запрос на участие должен содержать поля: id, requester, event, status, created\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('requester');\r",
                  "pm.expect(target).to.have.property('event');\r",
                  "pm.expect(target).to.have.property('status');\r",
                  "pm.expect(target).to.have.property('created');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.id).equal(target.id, 'Идентификатор запроса на участие в событии должен соответствовать идентификатору запроса на участие в событии указанного пользователя');\r",
                  "    pm.expect(source.requester).equal(target.requester, 'Автор запроса на участие в событии должен соответствовать указанному пользователю');\r",
                  "    pm.expect(source.event).equal(target.event, 'Событие в ответе должно соответствовать событию с запросом на участие от указанного пользователя');\r",
                  "    pm.expect(source.created).equal(target.created, 'Время создания запроса на участие в событии должно соответствовать времени создания запроса на участие в событии указанного пользователя');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/users/:userId/events/:eventId/requests",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "users",
                ":userId",
                "events",
                ":eventId",
                "requests"
              ],
              "variable": [
                {
                  "key": "userId",
                  "value": "{{uid}}",
                  "description": "(Required) id текущего пользователя"
                },
                {
                  "key": "eventId",
                  "value": "{{eid}}",
                  "description": "(Required) id события"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Публикация события",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                  "        pm.collectionVariables.set('response', event);\r",
                  "        pm.collectionVariables.set(\"eid\", event.id)\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, description, participantLimit, state, createdOn, publishedOn, location, requestModeration\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('title');\r",
                  "pm.expect(target).to.have.property('annotation');\r",
                  "pm.expect(target).to.have.property('category');\r",
                  "pm.expect(target).to.have.property('paid');\r",
                  "pm.expect(target).to.have.property('eventDate');\r",
                  "pm.expect(target).to.have.property('initiator');\r",
                  "pm.expect(target).to.have.property('description');\r",
                  "pm.expect(target).to.have.property('participantLimit');\r",
                  "pm.expect(target).to.have.property('state');\r",
                  "pm.expect(target).to.have.property('createdOn');\r",
                  "pm.expect(target).to.have.property('publishedOn');\r",
                  "pm.expect(target).to.have.property('location');\r",
                  "pm.expect(target).to.have.property('requestModeration');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.annotation).equal(target.annotation, 'Аннотация события должна соответствовать искомому событию');\r",
                  "    pm.expect(source.category.id).equal(target.category.id, 'Категория события должна соответствовать искомому событию');\r",
                  "    pm.expect(source.paid.toString()).equal(target.paid.toString(), 'Стоимость события должна соответствовать искомому событию');\r",
                  "    pm.expect(source.eventDate).equal(target.eventDate, 'Дата проведения события должна соответствовать искомому событию');\r",
                  "    pm.expect(source.description).equal(target.description, 'Описание события должно соответствовать искомому событию');\r",
                  "    pm.expect(source.title).equal(target.title, 'Название события должно соответствовать искомому событию');\r",
                  "    pm.expect(source.participantLimit.toString()).equal(target.participantLimit.toString(), 'Лимит участников события должен соответствовать искомому событию');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Событие должно иметь статус PENDING при создании и статус PUBLISHED после выполнения запроса\", function () {\r",
                  "    pm.expect(source.state).equal(\"PENDING\");\r",
                  "    pm.expect(target.state).equal(\"PUBLISHED\");\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/admin/events/:eventId/publish",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "events",
                ":eventId",
                "publish"
              ],
              "variable": [
                {
                  "key": "eventId",
                  "value": "{{eid}}",
                  "description": "(Required) id события"
                }
              ]
            },
            "description": "Обратите внимание:\n - дата начала события должна быть не ранее чем за час от даты публикации.\n- событие должно быть в состоянии ожидания публикации"
          },
          "response": []
        },
        {
          "name": "Отклонение события",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                  "        pm.collectionVariables.set('response', event);\r",
                  "        pm.collectionVariables.set(\"eid\", event.id)\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, description, participantLimit, state, createdOn, location, requestModeration\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('title');\r",
                  "pm.expect(target).to.have.property('annotation');\r",
                  "pm.expect(target).to.have.property('category');\r",
                  "pm.expect(target).to.have.property('paid');\r",
                  "pm.expect(target).to.have.property('eventDate');\r",
                  "pm.expect(target).to.have.property('initiator');\r",
                  "pm.expect(target).to.have.property('description');\r",
                  "pm.expect(target).to.have.property('participantLimit');\r",
                  "pm.expect(target).to.have.property('state');\r",
                  "pm.expect(target).to.have.property('createdOn');\r",
                  "pm.expect(target).to.have.property('location');\r",
                  "pm.expect(target).to.have.property('requestModeration');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.annotation).equal(target.annotation, 'Аннотация события должна соответствовать искомому событию');\r",
                  "    pm.expect(source.category.id).equal(target.category.id, 'Категория события должна соответствовать искомому событию');\r",
                  "    pm.expect(source.paid.toString()).equal(target.paid.toString(), 'Стоимость события должна соответствовать искомому событию');\r",
                  "    pm.expect(source.eventDate).equal(target.eventDate, 'Дата проведения события должна соответствовать искомому событию');\r",
                  "    pm.expect(source.description).equal(target.description, 'Описание события должно соответствовать искомому событию');\r",
                  "    pm.expect(source.title).equal(target.title, 'Название события должно соответствовать искомому событию');\r",
                  "    pm.expect(source.participantLimit.toString()).equal(target.participantLimit.toString(), 'Лимит участников события должен соответствовать искомому событию');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Событие должно иметь статус PENDING при создании и статус CANCELED после выполнения запроса\", function () {\r",
                  "    pm.expect(source.state).equal(\"PENDING\");\r",
                  "    pm.expect(target.state).equal(\"CANCELED\");\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/admin/events/:eventId/reject",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "events",
                ":eventId",
                "reject"
              ],
              "variable": [
                {
                  "key": "eventId",
                  "value": "{{eid}}",
                  "description": "(Required) id события"
                }
              ]
            },
            "description": "Обратите внимание: событие не должно быть опубликовано."
          },
          "response": []
        },
        {
          "name": "Изменение события добавленного текущим пользователем",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    let new_event, event;\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                  "        pm.collectionVariables.set(\"uid\", user.id)\r",
                  "        new_event = rnd.getEvent(category.id);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "\r",
                  "    pm.request.body.update({\r",
                  "        mode: 'raw',\r",
                  "        raw: JSON.stringify({\r",
                  "            \"annotation\": new_event.annotation,\r",
                  "            \"category\": new_event.category,\r",
                  "            \"description\": new_event.description,\r",
                  "            \"eventDate\": new_event.eventDate,\r",
                  "            \"eventId\": event.id,\r",
                  "            \"paid\": new_event.paid,\r",
                  "            \"participantLimit\": new_event.participantLimit,\r",
                  "            \"title\": new_event.title\r",
                  "        }),\r",
                  "        options: { raw: { language: 'json' } }\r",
                  "    });\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = JSON.parse(pm.request.body.raw);\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, description, participantLimit, state, createdOn, location, requestModeration\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('title');\r",
                  "pm.expect(target).to.have.property('annotation');\r",
                  "pm.expect(target).to.have.property('category');\r",
                  "pm.expect(target).to.have.property('paid');\r",
                  "pm.expect(target).to.have.property('eventDate');\r",
                  "pm.expect(target).to.have.property('initiator');\r",
                  "pm.expect(target).to.have.property('description');\r",
                  "pm.expect(target).to.have.property('participantLimit');\r",
                  "pm.expect(target).to.have.property('state');\r",
                  "pm.expect(target).to.have.property('createdOn');\r",
                  "pm.expect(target).to.have.property('location');\r",
                  "pm.expect(target).to.have.property('requestModeration');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.annotation).equal(target.annotation, 'Аннотация изменённого события должна соответствовать аннотации события, отправленной при изменении, или остаться без изменений');\r",
                  "    pm.expect(source.category).equal(target.category.id, 'Категория изменённого события должна соответствовать категории события, отправленной при изменении, или остаться без изменений');\r",
                  "    pm.expect(source.paid.toString()).equal(target.paid.toString(), 'Стоимость изменённого события должна соответствовать стоимости события, отправленной при изменении, или остаться без изменений');\r",
                  "    pm.expect(source.eventDate).equal(target.eventDate, 'Дата проведения изменённого события должна соответствовать дате проведения события, отправленной при изменении, или остаться без изменений');\r",
                  "    pm.expect(source.description).equal(target.description, 'описание изменённого события должно соответствовать описанию события, отправленному при изменении, или остаться без изменений');\r",
                  "    pm.expect(source.title).equal(target.title, 'Название изменённого события должно соответствовать названию события, отправленному при изменении, или остаться без изменений');\r",
                  "    pm.expect(source.participantLimit.toString()).equal(target.participantLimit.toString(), 'Лимит участников изменённого события должен соответствовать лимиту участников события, отправленному при изменении, или остаться без изменений');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{request_body}}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/users/:userId/events",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "users",
                ":userId",
                "events"
              ],
              "variable": [
                {
                  "key": "userId",
                  "value": "{{uid}}",
                  "description": "(Required) id текущего пользователя"
                }
              ]
            },
            "description": "Обратите внимание:\n- изменить можно только отмененные события или события в состоянии ожидания модерации\n- дата и время на которые намечено событие не может быть раньше, чем через два часа от текущего момента\n"
          },
          "response": []
        },
        {
          "name": "Отмена события добавленного текущим пользователем.",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    let new_event, event;\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                  "        pm.collectionVariables.set(\"uid\", user.id);\r",
                  "        pm.collectionVariables.set(\"eid\", event.id);\r",
                  "        pm.collectionVariables.set(\"response\", event);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get(\"response\");\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "\r",
                  "pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, description, participantLimit, state, createdOn, location, requestModeration\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('title');\r",
                  "pm.expect(target).to.have.property('annotation');\r",
                  "pm.expect(target).to.have.property('category');\r",
                  "pm.expect(target).to.have.property('paid');\r",
                  "pm.expect(target).to.have.property('eventDate');\r",
                  "pm.expect(target).to.have.property('initiator');\r",
                  "pm.expect(target).to.have.property('description');\r",
                  "pm.expect(target).to.have.property('participantLimit');\r",
                  "pm.expect(target).to.have.property('state');\r",
                  "pm.expect(target).to.have.property('createdOn');\r",
                  "pm.expect(target).to.have.property('location');\r",
                  "pm.expect(target).to.have.property('requestModeration');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.annotation).equal(target.annotation, 'Аннотация отменённого события должна соответствовать аннотации события до отмены');\r",
                  "    pm.expect(source.category.id).equal(target.category.id, 'Категория отменённого события должна соответствовать категории события до отмены');\r",
                  "    pm.expect(source.paid.toString()).equal(target.paid.toString(), 'Стоимость отменённого события должна соответствовать стоимости события до отмены');\r",
                  "    pm.expect(source.eventDate).equal(target.eventDate, 'Дата проведения отменённого события должна соответствовать дате проведения события до отмены');\r",
                  "    pm.expect(source.description).equal(target.description, 'Описание отменённого события должно соответствовать описанию события до отмены');\r",
                  "    pm.expect(source.title).equal(target.title, 'Название отменённого события должно соответствовать названию события до отмены');\r",
                  "    pm.expect(source.participantLimit.toString()).equal(target.participantLimit.toString(), 'Лимит участников отменённого события должен соответствовать лимиту участников события до отмены');\r",
                  "    pm.expect(source.paid.toString()).equal(target.paid.toString(), 'Стоимость отменённого события должна соответствовать стоимости события до отмены');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Событие должно иметь статус PENDING при создании и статус CANCELED после выполнения запроса\", function () {\r",
                  "    pm.expect(source.state).equal(\"PENDING\");\r",
                  "    pm.expect(target.state).equal(\"CANCELED\");\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/users/:userId/events/:eventId",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "users",
                ":userId",
                "events",
                ":eventId"
              ],
              "variable": [
                {
                  "key": "userId",
                  "value": "{{uid}}",
                  "description": "(Required) id текущего пользователя"
                },
                {
                  "key": "eventId",
                  "value": "{{eid}}",
                  "description": "(Required) id отменяемого события"
                }
              ]
            },
            "description": "Обратите внимание: Отменить можно только событие в состоянии ожидания модерации."
          },
          "response": []
        },
        {
          "name": "Отмена своего запроса на участие в событии",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let eventBody = rnd.getEvent(category.id);\r",
                  "        eventBody['requestModeration'] = true\r",
                  "        let event = await api.addEvent(user.id, eventBody);\r",
                  "        event = await api.publishEvent(event.id);\r",
                  "        const submittedUser = await api.addUser(rnd.getUser());\r",
                  "        const requestToJoin = await api.publishParticipationRequest(event.id, submittedUser.id);\r",
                  "        pm.collectionVariables.set('response', requestToJoin);\r",
                  "        pm.collectionVariables.set('uid', submittedUser.id);\r",
                  "        pm.collectionVariables.set('reqid', requestToJoin.id);\r",
                  "\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const target = pm.response.json();\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "\r",
                  "pm.test(\"Запрос на участие должен содержать поля: id, requester, event, status, created\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('requester');\r",
                  "pm.expect(target).to.have.property('event');\r",
                  "pm.expect(target).to.have.property('status');\r",
                  "pm.expect(target).to.have.property('created');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"При создании у запроса на участие должен быть статус PENDING, а при удалении - CANCELED\", function () {\r",
                  "    pm.expect(source.status).equal(\"PENDING\");\r",
                  "    pm.expect(target.status).equal(\"CANCELED\");\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.id).equal(target.id, 'Идентификатор отменённого запроса на участие в событии должен соответствовать идентификатору запроса до отмены');\r",
                  "    pm.expect(source.requester).equal(target.requester, 'Пользователь, отменяющий запрос на участие в событии, должен соответствовать текущему пользователю');\r",
                  "    pm.expect(source.event).equal(target.event, 'Событие отменённого запроса на участие должно соответствовать запросу на участие в событии до отмены');\r",
                  "    pm.expect(source.created).equal(target.created, 'Дата создания отменённого запроса на участие в событии должна соответствовать дате создания запроса до отмены');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/users/:userId/requests/:requestId/cancel",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "users",
                ":userId",
                "requests",
                ":requestId",
                "cancel"
              ],
              "variable": [
                {
                  "key": "userId",
                  "value": "{{uid}}",
                  "description": "(Required) id текущего пользователя"
                },
                {
                  "key": "requestId",
                  "value": "{{reqid}}",
                  "description": "(Required) id запроса на участие"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Отклонение чужой заявки на участие в событии текущего пользователя",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Запрос на участие должен содержать поля: id, requester, event, status, created\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('requester');\r",
                  "pm.expect(target).to.have.property('event');\r",
                  "pm.expect(target).to.have.property('status');\r",
                  "pm.expect(target).to.have.property('created');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.id).equal(target.id, 'Идентификатор запроса на участие в событии должен соответствовать идентификатору запроса на участие в событии указанного пользователя');\r",
                  "    pm.expect(source.requester).equal(target.requester, 'Пользователь, запрашивающий доступ на участие в событии должен пользователю, отправившему запрос на участие в событии указанного пользователя ранее');\r",
                  "    pm.expect(source.event).equal(target.event, 'Событие, запрос на участие в котором надо подтвердить, должно соответствовать событию указанного пользователя');\r",
                  "    pm.expect(source.created).equal(target.created, 'Время создания запроса на участие в событии после отклонения должно соответствовать времени создания запроса на участие в событии указанного пользователя до отклонения');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Запрос на участие должен иметь статус PENDING при создании и статус REJECTED после выполнения запроса\", function () {\r",
                  "    pm.expect(source.status).equal(\"PENDING\");\r",
                  "    pm.expect(target.status).equal(\"REJECTED\");\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let eventBody = rnd.getEvent(category.id);\r",
                  "        eventBody['requestModeration'] = true\r",
                  "        let event = await api.addEvent(user.id, eventBody);\r",
                  "        event = await api.publishEvent(event.id);\r",
                  "        const submittedUser = await api.addUser(rnd.getUser());\r",
                  "        const requestToJoin = await api.publishParticipationRequest(event.id, submittedUser.id);\r",
                  "        pm.collectionVariables.set('response', requestToJoin);\r",
                  "        pm.collectionVariables.set('uid', user.id);\r",
                  "        pm.collectionVariables.set('eid', event.id);\r",
                  "        pm.collectionVariables.set('reqid', requestToJoin.id);\r",
                  "\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/users/:userId/events/:eventId/requests/:reqId/reject",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "users",
                ":userId",
                "events",
                ":eventId",
                "requests",
                ":reqId",
                "reject"
              ],
              "variable": [
                {
                  "key": "userId",
                  "value": "{{uid}}",
                  "description": "(Required) id текущего пользователя"
                },
                {
                  "key": "eventId",
                  "value": "{{eid}}",
                  "description": "(Required) id события текущего пользователя"
                },
                {
                  "key": "reqId",
                  "value": "{{reqid}}",
                  "description": "(Required) id заявки, которую отменяет текущий пользователь"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Подтверждение чужой заявки на участие в событии текущего пользователя",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let eventBody = rnd.getEvent(category.id);\r",
                  "        eventBody['requestModeration'] = true\r",
                  "        let event = await api.addEvent(user.id, eventBody);\r",
                  "        event = await api.publishEvent(event.id);\r",
                  "        const submittedUser = await api.addUser(rnd.getUser());\r",
                  "        const requestToJoin = await api.publishParticipationRequest(event.id, submittedUser.id);\r",
                  "        pm.collectionVariables.set('response', requestToJoin);\r",
                  "        pm.collectionVariables.set('uid', user.id);\r",
                  "        pm.collectionVariables.set('eid', event.id);\r",
                  "        pm.collectionVariables.set('reqid', requestToJoin.id);\r",
                  "\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Запрос на участие должен содержать поля: id, requester, event, status, created\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('requester');\r",
                  "pm.expect(target).to.have.property('event');\r",
                  "pm.expect(target).to.have.property('status');\r",
                  "pm.expect(target).to.have.property('created');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.id).equal(target.id, 'Идентификатор запроса на участие в событии должен соответствовать идентификатору запроса на участие в событии указанного пользователя');\r",
                  "    pm.expect(source.requester).equal(target.requester, 'Пользователь, запрашивающий доступ на участие в событии должен пользователю, отправившему запрос на участие в событии указанного пользователя ранее');\r",
                  "    pm.expect(source.event).equal(target.event, 'Событие, запрос на участие в котором надо подтвердить, должно соответствовать событию указанного пользователя');\r",
                  "    pm.expect(source.created).equal(target.created, 'Время создания запроса на участие в событии после подтверждения должно соответствовать времени создания запроса на участие в событии указанного пользователя до подтверждения');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Запрос на участие должен иметь статус PENDING при создании и статус CONFIRMED после выполнения запроса\", function () {\r",
                  "    pm.expect(source.status).equal(\"PENDING\");\r",
                  "    pm.expect(target.status).equal(\"CONFIRMED\");\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/users/:userId/events/:eventId/requests/:reqId/confirm",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "users",
                ":userId",
                "events",
                ":eventId",
                "requests",
                ":reqId",
                "confirm"
              ],
              "variable": [
                {
                  "key": "userId",
                  "value": "{{uid}}",
                  "description": "(Required) id текущего пользователя"
                },
                {
                  "key": "eventId",
                  "value": "{{eid}}",
                  "description": "(Required) id события текущего пользователя"
                },
                {
                  "key": "reqId",
                  "value": "{{reqid}}",
                  "description": "(Required) id заявки, которую подтверждает текущий пользователь"
                }
              ]
            },
            "description": "Обратите внимание:\n- нельзя подтвердить заявку, если уже достигнут лимит по заявкам на данное событие\n- если при подтверждении данной заявки, лимит заявок для события исчерпан, то все неподтверждённые заявки необходимо отклонить"
          },
          "response": []
        },
        {
          "name": "Редактирование события",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    let new_event, event;\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                  "        event = await api.publishEvent(event.id);\r",
                  "        pm.collectionVariables.set(\"eid\", event.id)\r",
                  "        pm.collectionVariables.set(\"uid\", user.id)\r",
                  "        new_event = rnd.getEvent(category.id);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "\r",
                  "    pm.request.body.update({\r",
                  "        mode: 'raw',\r",
                  "        raw: JSON.stringify({\r",
                  "            \"annotation\": new_event.annotation,\r",
                  "            \"category\": new_event.category,\r",
                  "            \"description\": new_event.description,\r",
                  "            \"eventDate\": new_event.eventDate,\r",
                  "            \"paid\": new_event.paid,\r",
                  "            \"participantLimit\": new_event.participantLimit,\r",
                  "            \"title\": new_event.title\r",
                  "        }),\r",
                  "        options: { raw: { language: 'json' } }\r",
                  "    });\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = JSON.parse(pm.request.body.raw);\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, description, participantLimit, state, createdOn, location, requestModeration\", function () {\r",
                  "    pm.expect(target).to.have.property('id');\r",
                  "    pm.expect(target).to.have.property('title');\r",
                  "    pm.expect(target).to.have.property('annotation');\r",
                  "    pm.expect(target).to.have.property('category');\r",
                  "    pm.expect(target).to.have.property('paid');\r",
                  "    pm.expect(target).to.have.property('eventDate');\r",
                  "    pm.expect(target).to.have.property('initiator');\r",
                  "    pm.expect(target).to.have.property('description');\r",
                  "    pm.expect(target).to.have.property('participantLimit');\r",
                  "    pm.expect(target).to.have.property('state');\r",
                  "    pm.expect(target).to.have.property('createdOn');\r",
                  "    pm.expect(target).to.have.property('location');\r",
                  "    pm.expect(target).to.have.property('requestModeration');\r",
                  "    pm.expect(target).to.have.property('publishedOn');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.annotation).equal(target.annotation, 'Аннотация события должна соответствовать отправленной при редакции или не меняться');\r",
                  "    pm.expect(source.category).equal(target.category.id, 'Категория события должна соответствовать отправленной при редакции или не меняться');\r",
                  "    pm.expect(source.paid.toString()).equal(target.paid.toString(), 'Стоимость события должна соответствовать отправленной при редакции или не меняться');\r",
                  "    pm.expect(source.eventDate).equal(target.eventDate, 'Дата проведения события должна соответствовать отправленной при редакции или не меняться');\r",
                  "    pm.expect(source.description).equal(target.description, 'Описание события должно соответствовать отправленному при редакции или не меняться');\r",
                  "    pm.expect(source.title).equal(target.title, 'Название события должно соответствовать отправленному при редакции или не меняться');\r",
                  "    pm.expect(source.participantLimit.toString()).equal(target.participantLimit.toString(), 'Лимит числа участников события должен соответствовать отправленному при редакции или не меняться');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{request_body}}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/admin/events/:eventId",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "events",
                ":eventId"
              ],
              "variable": [
                {
                  "key": "eventId",
                  "value": "{{eid}}",
                  "description": "(Required) id события"
                }
              ]
            },
            "description": "Редактирование данных любого события администратором. Валидация данных не требуется."
          },
          "response": []
        }
      ]
    },
    {
      "name": "Compilation",
      "item": [
        {
          "name": "Добавление новой подборки",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    let compilation;\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        const event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                  "        compilation = rnd.getCompilation(event.id);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "\r",
                  "    pm.request.body.update({\r",
                  "        mode: 'raw',\r",
                  "        raw: JSON.stringify(compilation),\r",
                  "        options: { raw: { language: 'json' } }\r",
                  "    });\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = JSON.parse(pm.request.body.raw);\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Подборка должны содержать поля: id, title, pinned, events\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('title');\r",
                  "pm.expect(target).to.have.property('pinned');\r",
                  "pm.expect(target).to.have.property('events');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(target.id).to.not.be.null;\r",
                  "    pm.expect(target.title).to.be.a(\"string\");\r",
                  "    pm.expect(target.events).to.be.an(\"array\");\r",
                  "\r",
                  "    pm.expect(source.events[0]).equal(target.events[0].id, 'Идентификаторы событий в подборке должен быть идентичен идентификаторам, указанным при создании подборки ');\r",
                  "    pm.expect(source.title).equal(target.title, 'Название подборки должно соответствовать указанному при создании');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/admin/compilations",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "compilations"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Получение подборки событий по её id",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        const compilation = await api.addCompilation(rnd.getCompilation());\r",
                  "        pm.collectionVariables.set('response', compilation);\r",
                  "        pm.collectionVariables.set('compid', compilation.id);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const target = pm.response.json();\r",
                  "\r",
                  "pm.test(\"Подборка должны содержать поля: id, title, pinned, events\", function () {\r",
                  "pm.expect(target).to.have.property('id');\r",
                  "pm.expect(target).to.have.property('title');\r",
                  "pm.expect(target).to.have.property('pinned');\r",
                  "pm.expect(target).to.have.property('events');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.id).equal(target.id, 'Идентификатор подборки должен соответствовать идентификатору подборки добавленной ранее');\r",
                  "    pm.expect(source.title).equal(target.title, 'Название подборки должно соответствовать названию подборки добавленной ранее');\r",
                  "    pm.expect(source.pinned).equal(target.pinned, 'Закреплённость подборки должна соответствовать закреплённости подборки добавленной ранее');\r",
                  "    pm.expect(source.events.join()).equal(target.events.join(), 'События подборки должны соответствовать событиям подборки добавленной ранее');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/compilations/:compId",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "compilations",
                ":compId"
              ],
              "variable": [
                {
                  "key": "compId",
                  "value": "{{compid}}",
                  "description": "(Required) id подборки"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Получение подборок событий",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let newComp = rnd.getCompilation();\r",
                  "        newComp['pinned'] = true;\r",
                  "        const compilation = await api.addCompilation(newComp);\r",
                  "        pm.collectionVariables.set('response', compilation);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "    pm.response.to.be.withBody;\r",
                  "    pm.response.to.be.json;\r",
                  "});\r",
                  "\r",
                  "const source = pm.collectionVariables.get('response');\r",
                  "const target = pm.response.json();\r",
                  "let founded;\r",
                  "target.forEach(function(element){if (element.id == source.id) founded = element});\r",
                  "\r",
                  "pm.test(\"Подборка должны содержать поля: id, title, pinned, events\", function () {\r",
                  "pm.expect(target[0]).to.have.property('id');\r",
                  "pm.expect(target[0]).to.have.property('title');\r",
                  "pm.expect(target[0]).to.have.property('pinned');\r",
                  "pm.expect(target[0]).to.have.property('events');\r",
                  "});\r",
                  "\r",
                  "pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
                  "    pm.expect(source.id).equal(founded.id, 'Идентификатор подборки должен соответствовать идентификатору подборки добавленной ранее');\r",
                  "    pm.expect(source.title).equal(founded.title, 'Название подборки должно соответствовать названию подборки добавленной ранее');\r",
                  "    pm.expect(source.pinned).equal(founded.pinned, 'Закрепленность подборки должна соответствовать закрепленности подборки добавленной ранее');\r",
                  "    pm.expect(source.events.join()).equal(founded.events.join(), 'События подборки должны соответствовать событиям подборки добавленной ранее');\r",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/compilations?pinned=true&from=0&size=1000",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "compilations"
              ],
              "query": [
                {
                  "key": "pinned",
                  "value": "true",
                  "description": "искать только закрепленные/не закрепленные подборки"
                },
                {
                  "key": "from",
                  "value": "0",
                  "description": "количество элементов, которые нужно пропустить для формирования текущего набора"
                },
                {
                  "key": "size",
                  "value": "1000",
                  "description": "количество элементов в наборе"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Добавить событие в подборку",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                  "        event = await api.publishEvent(event.id);\r",
                  "        const compilation = await api.addCompilation(rnd.getCompilation());\r",
                  "        const foundedCompilation = await api.findCompilation(compilation.id);\r",
                  "        pm.collectionVariables.set('eid', event.id);\r",
                  "        pm.collectionVariables.set('compid', compilation.id);\r",
                  "        pm.collectionVariables.set('response', foundedCompilation);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "});\r",
                  "\r",
                  "source = pm.collectionVariables.get('response');\r",
                  "compId = pm.collectionVariables.get('compid');\r",
                  "eventId = pm.collectionVariables.get('eid');\r",
                  "\r",
                  "pm.test(\"Событие не должно быть найдено в подборке до добавления\", function () {\r",
                  "    pm.expect(source.events.length).equal(0);\r",
                  "});\r",
                  "\r",
                  "pm.sendRequest({\r",
                  "            url: pm.collectionVariables.get(\"baseUrl\") + \"/compilations/\" + compId,\r",
                  "            method: 'GET',\r",
                  "        }, (error, response) => {\r",
                  "            \r",
                  "            pm.test(\"Событие должно быть найдено в подборке после добавления\", function () {\r",
                  "                pm.expect(response.json().events[0].id).equal(eventId);\r",
                  "            });\r",
                  "        });"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/admin/compilations/:compId/events/:eventId",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "compilations",
                ":compId",
                "events",
                ":eventId"
              ],
              "variable": [
                {
                  "key": "compId",
                  "value": "{{compid}}",
                  "description": "(Required) id подборки"
                },
                {
                  "key": "eventId",
                  "value": "{{eid}}",
                  "description": "(Required) id события"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Закрепить подборку на главной странице",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let compilation = rnd.getCompilation();\r",
                  "        compilation.pinned = false;\r",
                  "        compilation = await api.addCompilation(compilation);\r",
                  "        const foundedCompilation = await api.findCompilation(compilation.id);\r",
                  "        pm.collectionVariables.set('compid', compilation.id);\r",
                  "        pm.collectionVariables.set('response', foundedCompilation);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "});\r",
                  "\r",
                  "source = pm.collectionVariables.get('response');\r",
                  "compId = pm.collectionVariables.get('compid');\r",
                  "\r",
                  "pm.test(\"Подборка должна быть откреплена до выполнения запроса\", function () {\r",
                  "    pm.expect(source.pinned).equal(false);\r",
                  "});\r",
                  "\r",
                  "pm.sendRequest({\r",
                  "            url: pm.collectionVariables.get(\"baseUrl\") + \"/compilations/\" + compId,\r",
                  "            method: 'GET',\r",
                  "        }, (error, response) => {\r",
                  "            \r",
                  "            pm.test(\"Подборка должна быть закреплена после выполнения запроса\", function () {\r",
                  "                pm.expect(response.json().pinned).equal(true);\r",
                  "            });\r",
                  "        });"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/admin/compilations/:compId/pin",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "compilations",
                ":compId",
                "pin"
              ],
              "variable": [
                {
                  "key": "compId",
                  "value": "{{compid}}",
                  "description": "(Required) id подборки"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Удаление подборки",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "});\r",
                  "\r",
                  "let source = pm.collectionVariables.get('response');\r",
                  "\r",
                  "pm.test(\"Подборка должна быть найдена до удаления\", function () {\r",
                  "    pm.expect(source).not.to.be.null;\r",
                  "});\r",
                  "\r",
                  "let body\r",
                  "const req = {\r",
                  "                url: \"http://localhost:8080/compilations?from=0&size=1000\" + pm.collectionVariables.get(\"uid\"),\r",
                  "                method: \"GET\",\r",
                  "                body: body == null ? \"\" : JSON.stringify(body),\r",
                  "                header: { \"Content-Type\": \"application/json\" },\r",
                  "            };\r",
                  "pm.sendRequest(req, (error, response) => {\r",
                  "    pm.test(\"Подборка должна быть удалена после выполнения запроса\", function(){\r",
                  "        response.json().forEach(element => {\r",
                  "            if(element.id == pm.collectionVariables.get('compid')){\r",
                  "                throw new Error(\"Подборка все еще находится в списке существующих\");\r",
                  "            }\r",
                  "        })\r",
                  "    });\r",
                  "})\r",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        const compilation = await api.addCompilation(rnd.getCompilation());\r",
                  "        const foundedCompilation = await api.findCompilation(compilation.id);\r",
                  "        pm.collectionVariables.set('compid', compilation.id);\r",
                  "        pm.collectionVariables.set('response', foundedCompilation);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/admin/compilations/:compId",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "compilations",
                ":compId"
              ],
              "variable": [
                {
                  "key": "compId",
                  "value": "{{compid}}",
                  "description": "(Required) id подборки"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Удалить событие из подборки",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
                  "        event = await api.publishEvent(event.id);\r",
                  "        const compilation = await api.addCompilation(rnd.getCompilation(event.id));\r",
                  "        const foundedCompilation = await api.findCompilation(compilation.id);\r",
                  "        pm.collectionVariables.set('eid', event.id);\r",
                  "        pm.collectionVariables.set('compid', compilation.id);\r",
                  "        pm.collectionVariables.set('response', foundedCompilation);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "});\r",
                  "\r",
                  "source = pm.collectionVariables.get('response');\r",
                  "compId = pm.collectionVariables.get('compid');\r",
                  "eventId = pm.collectionVariables.get('eid');\r",
                  "\r",
                  "pm.test(\"Событие должно быть найдено в подборке до удаления\", function () {\r",
                  "    pm.expect(source.events[0].id).equal(eventId);\r",
                  "});\r",
                  "\r",
                  "pm.sendRequest({\r",
                  "            url: pm.collectionVariables.get(\"baseUrl\") + \"/compilations/\" + compId,\r",
                  "            method: 'GET',\r",
                  "        }, (error, response) => {\r",
                  "            \r",
                  "            pm.test(\"Событие не должно быть найдено в подборке после удаления\", function () {\r",
                  "                pm.expect(response.json().events.length).equal(0);\r",
                  "            });\r",
                  "        });"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/admin/compilations/:compId/events/:eventId",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "compilations",
                ":compId",
                "events",
                ":eventId"
              ],
              "variable": [
                {
                  "key": "compId",
                  "value": "{{compid}}",
                  "description": "(Required) id подборки"
                },
                {
                  "key": "eventId",
                  "value": "{{eid}}",
                  "description": "(Required) id события"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Открепить подборку на главной странице",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const main = async () => {\r",
                  "    const api = new API(pm);\r",
                  "    const rnd = new RandomUtils();\r",
                  "\r",
                  "    try {\r",
                  "        const user = await api.addUser(rnd.getUser());\r",
                  "        const category = await api.addCategory(rnd.getCategory());\r",
                  "        let compilation = rnd.getCompilation();\r",
                  "        compilation.pinned = true;\r",
                  "        compilation = await api.addCompilation(compilation);\r",
                  "        const foundedCompilation = await api.findCompilation(compilation.id);\r",
                  "        pm.collectionVariables.set('compid', compilation.id);\r",
                  "        pm.collectionVariables.set('response', foundedCompilation);\r",
                  "    } catch(err) {\r",
                  "        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
                  "    }\r",
                  "};\r",
                  "\r",
                  "const interval = setInterval(() => {}, 1000);\r",
                  "\r",
                  "setTimeout(async () => \r",
                  "    {\r",
                  "        try {\r",
                  "            // выполняем наш скрипт\r",
                  "            await main();\r",
                  "        } catch (e) {\r",
                  "            console.error(e);\r",
                  "        } finally {\r",
                  "            clearInterval(interval);\r",
                  "        }\r",
                  "    },  \r",
                  "    100 \r",
                  ");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Ответ должен содержать код статуса 200\", function () {\r",
                  "    pm.response.to.be.ok;    \r",
                  "});\r",
                  "\r",
                  "source = pm.collectionVariables.get('response');\r",
                  "compId = pm.collectionVariables.get('compid');\r",
                  "\r",
                  "pm.test(\"Подборка должна быть закреплена до выполнения запроса\", function () {\r",
                  "    pm.expect(source.pinned).equal(true);\r",
                  "});\r",
                  "\r",
                  "pm.sendRequest({\r",
                  "            url: pm.collectionVariables.get(\"baseUrl\") + \"/compilations/\" + compId,\r",
                  "            method: 'GET',\r",
                  "        }, (error, response) => {\r",
                  "            \r",
                  "            pm.test(\"Подборка должна быть откреплена после выполнения запроса\", function () {\r",
                  "                pm.expect(response.json().pinned).equal(false);\r",
                  "            });\r",
                  "        });"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/admin/compilations/:compId/pin",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "admin",
                "compilations",
                ":compId",
                "pin"
              ],
              "variable": [
                {
                  "key": "compId",
                  "value": "{{compid}}",
                  "description": "(Required) id подборки"
                }
              ]
            }
          },
          "response": []
        }
      ]
    }
  ],
  "event": [
    {
      "listen": "prerequest",
      "script": {
        "type": "text/javascript",
        "exec": [
          "API = class {",
          "    constructor(postman, verbose = false, baseUrl = \"http://localhost:8080\") {",
          "        this.baseUrl = baseUrl;",
          "        this.pm = postman;",
          "        this._verbose = verbose;",
          "    }",
          "",
          "    async addUser(user, verbose=null) {",
          "        return this.post(\"/admin/users\", user, \"Ошибка при добавлении нового пользователя: \", verbose);",
          "    }",
          "",
          "    async addCategory(category, verbose=null) {",
          "        return this.post(\"/admin/categories\", category, \"Ошибка при добавлении новой категории: \", verbose);",
          "    }",
          "",
          "    async addEvent(userId, event, verbose=null) {",
          "        return this.post(\"/users/\" + userId + \"/events\", event, \"Ошибка при добавлении нового события: \", verbose);",
          "    }",
          "",
          "    async addCompilation(compilation, verbose=null) {",
          "        return this.post(\"/admin/compilations\", compilation, \"Ошибка при добавлении новой подборки: \", verbose);",
          "    }",
          "",
          "    async publishParticipationRequest(eventId, userId, verbose=null) {",
          "        return this.post('/users/' + userId + '/requests?eventId=' + eventId, \"Ошибка при добавлении нового запроса на участие в событии\", verbose);",
          "    }",
          "",
          "    async publishEvent(eventId, verbose=null) {",
          "        return this.patch('/admin/events/' + eventId + '/publish', \"Ошибка при публикации события\", verbose);",
          "    }",
          "",
          "    async acceptParticipationRequest(eventId, userId, reqId, verbose=null) {",
          "        return this.patch('/users/' + userId + '/events/' + eventId + '/requests/' + reqId + '/confirm', \"Ошибка при принятии заявки на участие в событии\", verbose);",
          "    }",
          "",
          "    async findCategory(catId, verbose=null) {",
          "        return this.get('/categories/' + catId, \"Ошибка при поиске категории по id\", verbose);",
          "    }",
          "",
          "    async findCompilation(compId, verbose=null) {",
          "        return this.get('/compilations/' + compId, \"Ошибка при поиске подборки по id\", verbose);",
          "    }",
          "",
          "    async findUser(userId, verbose=null) {",
          "        return this.get('/admin/users?ids=' + userId, \"Ошибка при поиске пользователя по id\", verbose);",
          "    }",
          "",
          "    async post(path, body, errorText = \"Ошибка при выполнении post-запроса: \", verbose=null) {",
          "        return this.sendRequest(\"POST\", path, body, errorText);",
          "    }",
          "",
          "    async patch(path, body = null, errorText = \"Ошибка при выполнении patch-запроса: \", verbose=null) {",
          "        return this.sendRequest(\"PATCH\", path, body, errorText);",
          "    }",
          "",
          "    async get(path, body = null, errorText = \"Ошибка при выполнении get-запроса: \", verbose=null) {",
          "        return this.sendRequest(\"GET\", path, body, errorText);",
          "    }",
          "",
          "    async sendRequest(method, path, body=null, errorText = \"Ошибка при выполнении запроса: \", verbose=null) {",
          "        return new Promise((resolve, reject) => {",
          "            verbose = verbose == null ? this._verbose : verbose;",
          "",
          "            const request = {",
          "                url: this.baseUrl + path,",
          "                method: method,",
          "                body: body == null ? \"\" : JSON.stringify(body),",
          "                header: { \"Content-Type\": \"application/json\" },",
          "            };",
          "",
          "            if(verbose) {",
          "                console.log(\"Отправляю запрос: \", request);",
          "            }",
          "",
          "            try {",
          "                this.pm.sendRequest(request, (error, response) => {",
          "                    if(error || (response.code >= 400 && response.code <= 599)) {",
          "                        let err = error ? error : JSON.stringify(response.json());",
          "                        console.error(\"При выполнении запроса к серверу возникла ошика.\\n\", err,",
          "                             \"\\nДля отладки проблемы повторите такой же запрос к вашей программе \" + ",
          "                             \"на локальном компьютере. Данные запроса:\\n\", JSON.stringify(request));",
          "",
          "                        reject(new Error(errorText + err));",
          "                    }",
          "",
          "                    if(verbose) {",
          "                        console.log(\"Результат обработки запроса: код состояния - \", response.code, \", тело: \", response.json());",
          "                    }",
          "",
          "                    resolve(response.json());",
          "                });",
          "            } catch(err) {",
          "                if(verbose) {",
          "                    console.error(errorText, err);",
          "                }",
          "                return Promise.reject(err);",
          "            }",
          "        });",
          "    }",
          "};",
          "",
          "RandomUtils = class {",
          "    constructor() {}",
          "",
          "    getUser() {",
          "        return {",
          "            name: pm.variables.replaceIn('{{$randomFullName}}'),",
          "            email: pm.variables.replaceIn('{{$randomEmail}}')",
          "        };",
          "    }",
          "",
          "    getCategory() {",
          "        return {",
          "            name: pm.variables.replaceIn('{{$randomWord}}') + Math.floor(Math.random() * 100).toString()",
          "        };",
          "    }",
          "",
          "    getEvent(categoryId) {",
          "        return {",
          "            annotation: pm.variables.replaceIn('{{$randomLoremParagraph}}'),",
          "            category: categoryId,",
          "            description: pm.variables.replaceIn('{{$randomLoremParagraphs}}'),",
          "            eventDate: this.getFutureDateTime(),",
          "            location: {",
          "                lat: parseFloat(pm.variables.replaceIn('{{$randomLatitude}}')),",
          "                lon: parseFloat(pm.variables.replaceIn('{{$randomLongitude}}')),",
          "            },",
          "            paid: pm.variables.replaceIn('{{$randomBoolean}}'),",
          "            participantLimit: pm.variables.replaceIn('{{$randomInt}}'),",
          "            requestModeration: pm.variables.replaceIn('{{$randomBoolean}}'),",
          "            title: pm.variables.replaceIn('{{$randomLoremSentence}}'),",
          "        }",
          "    }",
          "",
          "    getCompilation(...eventIds) {",
          "        return {",
          "            title: pm.variables.replaceIn('{{$randomLoremSentence}}'),",
          "            pinned: pm.variables.replaceIn('{{$randomBoolean}}'),",
          "            events: eventIds",
          "        };",
          "    }",
          "",
          "    getFutureDateTime(hourShift = 5, minuteShift=0, yearShift=0) {",
          "        let moment = require('moment');",
          "",
          "        let m = moment();",
          "        m.add(hourShift, 'hour');",
          "        m.add(minuteShift, 'minute');",
          "        m.add(yearShift, 'year');",
          "",
          "        return m.format('YYYY-MM-DD HH:mm:ss');",
          "    }",
          "}"
        ]
      }
    },
    {
      "listen": "test",
      "script": {
        "type": "text/javascript",
        "exec": [
          ""
        ]
      }
    }
  ],
  "variable": [
    {
      "key": "baseUrl",
      "value": "http://localhost:8080",
      "type": "string"
    },
    {
      "key": "name",
      "value": ""
    },
    {
      "key": "usersCount",
      "value": 1,
      "type": "number"
    },
    {
      "key": "catid",
      "value": 1,
      "type": "number"
    },
    {
      "key": "request_body",
      "value": ""
    },
    {
      "key": "mail",
      "value": ""
    },
    {
      "key": "response",
      "value": ""
    },
    {
      "key": "uid",
      "value": 1,
      "type": "number"
    },
    {
      "key": "catname",
      "value": ""
    },
    {
      "key": "eid",
      "value": 1,
      "type": "number"
    },
    {
      "key": "compid",
      "value": 1,
      "type": "number"
    },
    {
      "key": "toCheck",
      "value": ""
    },
    {
      "key": "newDataToSet",
      "value": ""
    },
    {
      "key": "uid1",
      "value": ""
    },
    {
      "key": "reqid",
      "value": 1,
      "type": "number"
    }
  ]
}